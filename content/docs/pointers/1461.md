---
title: 1461. Check If a String Contains All Binary Codes of Size K
weight: 4
---
# 1461. Check If a String Contains All Binary Codes of Size K

[leetcode link](https://leetcode.com/problems/check-if-a-string-contains-all-binary-codes-of-size-k/)

**difficulty(1-5)** 
2

**notes**   


## Description

Given a binary string s and an integer k.

Return True if every binary code of length k is a substring of s. Otherwise, return False.

 

Example 1:

Input: s = "00110110", k = 2
Output: true
Explanation: The binary codes of length 2 are "00", "01", "10" and "11". They can be all found as substrings at indicies 0, 1, 3 and 2 respectively.
Example 2:

Input: s = "00110", k = 2
Output: true
Example 3:

Input: s = "0110", k = 1
Output: true
Explanation: The binary codes of length 1 are "0" and "1", it is clear that both exist as a substring. 
Example 4:

Input: s = "0110", k = 2
Output: false
Explanation: The binary code "00" is of length 2 and doesn't exist in the array.
Example 5:

Input: s = "0000000001011100", k = 4
Output: false
 

Constraints:

1 <= s.length <= 5 * 10^5
s consists of 0's and 1's only.
1 <= k <= 20

## Solution

This problem is actually asking, using moving window size k, take all these substring out and put them into hash table (to remove duplicates). Is non duplicate substrings number equals to 2^k?

```c++
class Solution {
public:
    bool hasAllCodes(string s, int k) {
        if (k < 0){
            return k == 0;
        }
        unordered_set<string> seen;
        for(int i = 0; i+k <= s.length(); i++){
            // int j = i+k-1; j < s.length() => i+k <= s.length()
            string tmp = s.substr(i, k);
            seen.insert(tmp);
        }
        return seen.size() == pow(2,k);        
    }
};
```